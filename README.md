## 컨트롤러 테스트

@WebMvcTest , @MockBean 어노테이션을 사용하여 컨트롤러를 테스트할 수 있습니다.

validation 체크하면 리스폰스나 에러의 응답 상태, 응답코드, 메세지 등도 체크할 수 있는데 여기까지 해야하나 싶긴함.

추후 복습해야할 것들 


### 더 나은 테스트를 구한 구체적인 방안

1. 하나의 테스트케이스엔 하나의 기능만 체크를 해야한다.

테스트코드는 일종의 문서역할을 하기 때문에 명확하게 그 기능을 이해할 수 있어야한다.
따라서 무엇을 테스트하는지 명확하게 알 수 있도록 작성해야한다.

2. 완벽하게 제어하기

LocalDateTime, Random 등은 테스트를 작성할 때 제어하기 어려운 부분이 있다.
따라서 테스트를 작성할 때는 이러한 부분을 제어할 수 있는 방법을 사용해야한다.
예를 들어 LocalDateTime.now()를 사용하는 대신, 테스트용으로 현재 시간을 주입받는 방법을 사용할 수 있다.
테스트하는 서버마다 시간이 달라서 문제가 생길 수 있고 테스트가 커져감에 따라 테스트가 실패할 가능성이 높아진다.
즉, 테스트코드엔 왠만하면 now()를 사용하지 않는 것이 좋다.

3. 테스트 환경의 독립성을 보장하자.

give엔 왠만하면 생성자를 통해서 환경을 구성하는 것이 좋다.
그리고 테스트의 검증은 when/then을 통해 구성해야지 given에서 여러 메소드나 환경을 통해 논리구조를 추가하여
한번 더 고민해야하는 구조는 지양해야한다.

가령 given에서 재고를 2개 추가를 했는데 재고를 3개 뺀다는 가정을 할 경우 when/then에서 예외체크를 하는 것이 아니라
given에서 잘못되기 때문에 이러한 경우를 조심해야한다.

4. 테스트 간 독립성을 보장하자.

A 테스트가 먼저 수행하든 B 테스트가 먼저 수행하든 상관없이 항상 동일한 결과를 보장해야한다.
또한 전역 필드의 공유자원을 통해 테스트를 수행하는 것은 지양해야한다.

5. 테스트수행도 비용이다.

abstract class를 상속받아 테스트를 실행하면 spring boot를 한번만 실행한 후 여러 테스트들이 하나의 스프링 부트서버에 동작하도록 작업을 한다.

- @MockBean을 사용하는 경우 상위 클래스로 올려서 재사용하고 
- @DataJpaTest를 사용하는 경우 상속받아서 사용하되 테스트 클래스에 @Transactional을 붙여서 테스트가 끝나면 롤백되도록 한다.
- @WebMvcTest를 사용하는 경우에도 아래와 같이 작성하여 환경을 구성한다.

```java
@WebMvcTest(controllers = {
    ProductController.class,
    OrderController.class})
public class ControllerTest {

    @Autowired
    protected MockMvc mockMvc;

    @MockBean
    protected Service service;
}
```