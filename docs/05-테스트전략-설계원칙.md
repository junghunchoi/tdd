# 테스트 전략 및 설계 원칙

## 목차
1. [테스트 피라미드](#테스트-피라미드)
2. [테스트 분류와 전략](#테스트-분류와-전략)
3. [테스트 설계 원칙](#테스트-설계-원칙)
4. [테스트 커버리지 전략](#테스트-커버리지-전략)
5. [테스트 환경 전략](#테스트-환경-전략)
6. [테스트 데이터 관리](#테스트-데이터-관리)
7. [CI/CD와 테스트 자동화](#cicd와-테스트-자동화)
8. [성능 테스트 전략](#성능-테스트-전략)
9. [테스트 유지보수 전략](#테스트-유지보수-전략)

## 테스트 피라미드

### 테스트 피라미드 개념
테스트 피라미드는 효과적인 테스트 전략을 시각화한 모델입니다. 피라미드의 각 층은 다른 종류의 테스트를 나타내며, 아래층일수록 더 많은 테스트가 있어야 합니다.

```
        /\
       /  \
      / UI \     ← 적은 수, 느림, 비싸지만 실제 사용자 경험 검증
     /------\
    /        \
   / Service \   ← 중간 수, 중간 속도, API/비즈니스 로직 검증
  /----------\
 /            \
/ Unit Tests  \  ← 많은 수, 빠름, 저렴하지만 세밀한 검증
--------------
```

### 각 레벨별 특성과 예시

#### 1. Unit Tests (단위 테스트)
```java
// 단위 테스트 예시 - 개별 메서드/클래스 검증
@Test
void 할인율_계산_정확성() {
    // given
    DiscountCalculator calculator = new DiscountCalculator();
    
    // when
    double discount = calculator.calculateDiscount(10000, CustomerType.VIP);
    
    // then
    assertEquals(1000, discount);  // VIP는 10% 할인
}

@Test
void 잘못된_고객_타입_예외_발생() {
    DiscountCalculator calculator = new DiscountCalculator();
    
    assertThrows(IllegalArgumentException.class, () -> {
        calculator.calculateDiscount(10000, null);
    });
}

// 특성:
// - 빠른 실행 (밀리초 단위)
// - 격리된 환경
// - 외부 의존성 없음 (Mock 사용)
// - 높은 커버리지 달성 가능
```

#### 2. Integration Tests (통합 테스트)
```java
// 통합 테스트 예시 - 여러 컴포넌트 간 협력 검증
@SpringBootTest
@Transactional
class OrderServiceIntegrationTest {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private PaymentService paymentService;
    
    @Test
    void 주문_생성_전체_플로우() {
        // given
        CreateOrderRequest request = new CreateOrderRequest(
            "customer1", 
            Arrays.asList(new OrderItem("product1", 2, 50000))
        );
        
        // when
        Order order = orderService.createOrder(request);
        
        // then
        assertNotNull(order.getId());
        assertEquals(OrderStatus.PENDING, order.getStatus());
        assertEquals(100000, order.getTotalAmount());
        
        // 데이터베이스에 실제 저장 확인
        Order savedOrder = orderRepository.findById(order.getId()).orElse(null);
        assertNotNull(savedOrder);
        assertEquals(2, savedOrder.getOrderItems().size());
    }
}

// 특성:
// - 중간 속도 (초 단위)
// - 실제 데이터베이스 사용
// - 여러 서비스 계층 협력 검증
// - 비즈니스 워크플로우 검증
```

#### 3. End-to-End Tests (E2E 테스트)
```java
// E2E 테스트 예시 - 전체 시스템 사용자 시나리오 검증
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderE2ETest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @LocalServerPort
    private int port;
    
    @Test
    void 주문_생성부터_결제까지_전체_플로우() {
        // given - 사용자 생성
        CreateUserRequest userRequest = new CreateUserRequest("john@example.com", "password");
        ResponseEntity<User> userResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/users", userRequest, User.class);
        
        User user = userResponse.getBody();
        
        // 상품 등록
        CreateProductRequest productRequest = new CreateProductRequest("Laptop", 50000);
        ResponseEntity<Product> productResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/products", productRequest, Product.class);
        
        // when - 주문 생성
        CreateOrderRequest orderRequest = new CreateOrderRequest(
            user.getId(), 
            Arrays.asList(new OrderItem(productResponse.getBody().getId(), 1))
        );
        
        ResponseEntity<Order> orderResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/orders", orderRequest, Order.class);
        
        // 결제 처리
        ProcessPaymentRequest paymentRequest = new ProcessPaymentRequest(
            orderResponse.getBody().getId(), "CREDIT_CARD"
        );
        
        ResponseEntity<PaymentResult> paymentResponse = restTemplate.postForEntity(
            "http://localhost:" + port + "/api/payments", paymentRequest, PaymentResult.class);
        
        // then
        assertEquals(HttpStatus.CREATED, orderResponse.getStatusCode());
        assertEquals(HttpStatus.OK, paymentResponse.getStatusCode());
        assertTrue(paymentResponse.getBody().isSuccessful());
        
        // 최종 주문 상태 확인
        ResponseEntity<Order> finalOrderResponse = restTemplate.getForEntity(
            "http://localhost:" + port + "/api/orders/" + orderResponse.getBody().getId(), 
            Order.class);
        
        assertEquals(OrderStatus.COMPLETED, finalOrderResponse.getBody().getStatus());
    }
}

// 특성:
// - 느린 실행 (분 단위)
// - 전체 시스템 검증
// - 실제 사용자 시나리오
// - 높은 신뢰성, 높은 비용
```

### 최적의 테스트 분배 비율
```java
// 권장 비율 (프로젝트 특성에 따라 조정)
public class TestDistributionStrategy {
    
    // 단위 테스트: 70% (빠르고 저렴한 피드백)
    @Test void unitTest1() { /* 빠른 검증 */ }
    @Test void unitTest2() { /* 세부 로직 검증 */ }
    @Test void unitTest3() { /* 예외 상황 검증 */ }
    // ... 더 많은 단위 테스트
    
    // 통합 테스트: 20% (중요한 워크플로우)
    @Test void integrationTest1() { /* 핵심 비즈니스 플로우 */ }
    @Test void integrationTest2() { /* 데이터 일관성 검증 */ }
    
    // E2E 테스트: 10% (핵심 사용자 여정)
    @Test void e2eTest1() { /* 가장 중요한 사용자 시나리오 */ }
}

// 실제 프로젝트 적용 예시
@Tag("unit")
class PricingServiceUnitTest {
    // 가격 계산 로직의 모든 경우의 수 테스트
    // 빠른 실행, 높은 커버리지
}

@Tag("integration") 
class OrderWorkflowIntegrationTest {
    // 주문 생성, 재고 차감, 결제 연동 등 핵심 워크플로우
    // 중간 속도, 실제 비즈니스 시나리오
}

@Tag("e2e")
class CriticalUserJourneyE2ETest {
    // 회원가입 → 상품 조회 → 주문 → 결제 완료
    // 느린 실행, 실제 사용자 경험
}
```

## 테스트 분류와 전략

### 기능별 테스트 분류

#### 1. 비즈니스 로직 테스트
```java
// 핵심 비즈니스 규칙 검증
@Test
void VIP_고객_특별_혜택_적용() {
    // given
    Customer vipCustomer = Customer.builder()
        .membershipLevel(MembershipLevel.VIP)
        .totalPurchaseAmount(1000000)
        .build();
    
    Order order = Order.builder()
        .customer(vipCustomer)
        .totalAmount(50000)
        .build();
    
    // when
    BenefitCalculationResult result = benefitService.calculateBenefits(order);
    
    // then
    assertThat(result.getDiscountAmount()).isEqualTo(5000);  // 10% 할인
    assertThat(result.getFreeShipping()).isTrue();          // 무료 배송
    assertThat(result.getBonusPoints()).isEqualTo(1000);     // 보너스 포인트
}

@Test
void 재고_부족시_주문_실패() {
    // given
    Product product = new Product("laptop", 5);  // 재고 5개
    OrderRequest request = new OrderRequest("laptop", 10);  // 10개 주문
    
    // when & then
    assertThrows(InsufficientStockException.class, () -> {
        orderService.createOrder(request);
    });
    
    // 재고가 변경되지 않았는지 확인
    assertEquals(5, product.getStockQuantity());
}
```

#### 2. 데이터 접근 계층 테스트
```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void 이메일로_사용자_조회() {
        // given
        User user = new User("john@example.com", "John Doe");
        entityManager.persistAndFlush(user);
        
        // when
        Optional<User> found = userRepository.findByEmail("john@example.com");
        
        // then
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John Doe");
    }
    
    @Test
    void 활성_사용자만_조회() {
        // given
        User activeUser = new User("active@example.com", "Active User", UserStatus.ACTIVE);
        User inactiveUser = new User("inactive@example.com", "Inactive User", UserStatus.INACTIVE);
        
        entityManager.persist(activeUser);
        entityManager.persist(inactiveUser);
        entityManager.flush();
        
        // when
        List<User> activeUsers = userRepository.findByStatus(UserStatus.ACTIVE);
        
        // then
        assertThat(activeUsers).hasSize(1);
        assertThat(activeUsers.get(0).getEmail()).isEqualTo("active@example.com");
    }
    
    @Test
    void 커스텀_쿼리_성능_검증() {
        // given - 대량 데이터 생성
        for (int i = 0; i < 1000; i++) {
            User user = new User("user" + i + "@example.com", "User " + i);
            entityManager.persist(user);
        }
        entityManager.flush();
        
        // when
        long startTime = System.currentTimeMillis();
        List<User> users = userRepository.findUsersWithComplexQuery();
        long endTime = System.currentTimeMillis();
        
        // then
        assertThat(users).isNotEmpty();
        assertThat(endTime - startTime).isLessThan(1000);  // 1초 이내 실행
    }
}
```

#### 3. 웹 계층 테스트
```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    void 사용자_생성_API() throws Exception {
        // given
        CreateUserRequest request = new CreateUserRequest("john@example.com", "John Doe");
        User createdUser = new User("1", "john@example.com", "John Doe");
        
        when(userService.createUser(any(CreateUserRequest.class))).thenReturn(createdUser);
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value("1"))
                .andExpect(jsonPath("$.email").value("john@example.com"))
                .andExpect(jsonPath("$.name").value("John Doe"));
    }
    
    @Test
    void 잘못된_요청_데이터_검증() throws Exception {
        // given - 잘못된 이메일 형식
        CreateUserRequest invalidRequest = new CreateUserRequest("invalid-email", "");
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.errors").isArray())
                .andExpect(jsonPath("$.errors[*].field").value(containsInAnyOrder("email", "name")));
    }
    
    @Test
    void 인증_필요한_API_접근_제어() throws Exception {
        mockMvc.perform(get("/api/users/profile"))
                .andExpect(status().isUnauthorized());
        
        mockMvc.perform(get("/api/users/profile")
                .header("Authorization", "Bearer valid-token"))
                .andExpect(status().isOk());
    }
}
```

### 품질 관점별 테스트 분류

#### 1. 보안 테스트
```java
@SpringBootTest
class SecurityTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void SQL_인젝션_방어() throws Exception {
        String maliciousInput = "'; DROP TABLE users; --";
        
        mockMvc.perform(get("/api/users/search")
                .param("name", maliciousInput))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.users").isEmpty());  // 결과 없음 (정상)
        
        // 사용자 테이블이 여전히 존재하는지 확인
        mockMvc.perform(get("/api/users"))
                .andExpect(status().isOk());
    }
    
    @Test
    void XSS_방어() throws Exception {
        String xssPayload = "<script>alert('xss')</script>";
        
        CreateUserRequest request = new CreateUserRequest("test@example.com", xssPayload);
        
        MvcResult result = mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andReturn();
        
        String responseBody = result.getResponse().getContentAsString();
        assertThat(responseBody).doesNotContain("<script>");  // 스크립트 태그 이스케이프됨
    }
    
    @Test
    void 권한_기반_접근_제어() throws Exception {
        // 관리자만 접근 가능한 API
        mockMvc.perform(delete("/api/users/1")
                .header("Authorization", "Bearer user-token"))
                .andExpect(status().isForbidden());
        
        mockMvc.perform(delete("/api/users/1")
                .header("Authorization", "Bearer admin-token"))
                .andExpect(status().isOk());
    }
}
```

#### 2. 성능 테스트
```java
@Test
void 대량_데이터_처리_성능() {
    // given
    List<User> largeUserList = IntStream.range(0, 10000)
        .mapToObj(i -> new User("user" + i + "@example.com", "User " + i))
        .collect(Collectors.toList());
    
    // when
    long startTime = System.currentTimeMillis();
    BatchProcessResult result = userService.batchCreateUsers(largeUserList);
    long endTime = System.currentTimeMillis();
    
    // then
    assertThat(result.getSuccessCount()).isEqualTo(10000);
    assertThat(endTime - startTime).isLessThan(5000);  // 5초 이내 처리
}

@Test
void 동시성_테스트() throws InterruptedException {
    int threadCount = 100;
    CountDownLatch latch = new CountDownLatch(threadCount);
    AtomicInteger successCount = new AtomicInteger(0);
    
    for (int i = 0; i < threadCount; i++) {
        new Thread(() -> {
            try {
                userService.createUser(new CreateUserRequest("test@example.com", "Test"));
                successCount.incrementAndGet();
            } catch (Exception e) {
                // 예외 처리
            } finally {
                latch.countDown();
            }
        }).start();
    }
    
    latch.await(10, TimeUnit.SECONDS);
    
    // 동시성 제어가 올바르게 작동하는지 확인
    assertThat(successCount.get()).isEqualTo(1);  // 첫 번째 요청만 성공
}
```

#### 3. 가용성 테스트
```java
@Test
void 외부_서비스_장애시_graceful_degradation() {
    // given - 외부 서비스 장애 시뮬레이션
    when(externalPaymentService.processPayment(any()))
        .thenThrow(new ServiceUnavailableException("Payment service down"));
    
    // when
    OrderResult result = orderService.createOrder(orderRequest);
    
    // then - 주문은 생성되지만 결제는 나중에 처리
    assertThat(result.getOrder().getStatus()).isEqualTo(OrderStatus.PAYMENT_PENDING);
    assertThat(result.getMessage()).contains("결제는 나중에 처리됩니다");
}

@Test
void 서킷_브레이커_동작() {
    // given - 연속 실패로 서킷 브레이커 열림
    for (int i = 0; i < 5; i++) {
        when(externalApiService.callExternalApi()).thenThrow(new RuntimeException());
        
        try {
            apiGateway.callApi();
        } catch (Exception e) {
            // 예외 무시
        }
    }
    
    // when - 서킷 브레이커가 열린 상태에서 호출
    ApiResult result = apiGateway.callApi();
    
    // then - 빠르게 실패하고 기본값 반환
    assertThat(result.isFromFallback()).isTrue();
    assertThat(result.getResponse()).isEqualTo("Default response");
}
```

## 테스트 설계 원칙

### FIRST 원칙

#### 1. Fast (빠른 실행)
```java
// ❌ 느린 테스트
@Test
void 느린_테스트_예시() {
    // 실제 데이터베이스 연결
    DatabaseConnection connection = DriverManager.getConnection("jdbc:mysql://...");
    
    // 복잡한 계산
    for (int i = 0; i < 1000000; i++) {
        complexCalculation();
    }
    
    // 외부 API 호출
    RestTemplate restTemplate = new RestTemplate();
    restTemplate.getForObject("http://external-api.com/slow-endpoint", String.class);
}

// ✅ 빠른 테스트
@Test
void 빠른_테스트_예시() {
    // 메모리 기반 데이터베이스
    @DataJpaTest  // H2 메모리 DB 사용
    
    // Mock 사용
    ExternalApiService mockApiService = mock(ExternalApiService.class);
    when(mockApiService.callApi()).thenReturn("mocked response");
    
    // 단순한 검증
    assertEquals(expected, actual);
}
```

#### 2. Independent (독립적)
```java
// ❌ 의존적인 테스트
class DependentTestExample {
    private static User globalUser;
    
    @Test
    void 테스트1_사용자_생성() {
        globalUser = userService.createUser("test@example.com");
        assertNotNull(globalUser);
    }
    
    @Test
    void 테스트2_사용자_업데이트() {
        // 테스트1에 의존
        globalUser.setName("Updated Name");
        userService.updateUser(globalUser);
        assertEquals("Updated Name", globalUser.getName());
    }
}

// ✅ 독립적인 테스트
class IndependentTestExample {
    
    @Test
    void 사용자_생성_테스트() {
        User user = userService.createUser("test1@example.com");
        assertNotNull(user);
    }
    
    @Test
    void 사용자_업데이트_테스트() {
        // 독립적으로 사용자 생성
        User user = userService.createUser("test2@example.com");
        user.setName("Updated Name");
        userService.updateUser(user);
        assertEquals("Updated Name", user.getName());
    }
    
    @BeforeEach
    void setUp() {
        // 각 테스트마다 깨끗한 상태로 시작
        databaseCleaner.cleanUp();
    }
}
```

#### 3. Repeatable (반복 가능)
```java
// ❌ 반복할 수 없는 테스트
@Test
void 시간_의존적_테스트() {
    Order order = new Order();
    order.setCreatedAt(LocalDateTime.now());
    
    // 현재 시간에 따라 결과가 달라짐
    boolean isExpired = order.isExpiredAfter(Duration.ofHours(24));
    assertTrue(isExpired);  // 내일이 되면 실패할 수 있음
}

// ✅ 반복 가능한 테스트
@Test
void 시간_독립적_테스트() {
    // 고정된 시간 사용
    LocalDateTime fixedTime = LocalDateTime.of(2023, 1, 1, 10, 0);
    Order order = new Order();
    order.setCreatedAt(fixedTime);
    
    // 24시간 후 시점으로 고정
    LocalDateTime checkTime = fixedTime.plusHours(25);
    boolean isExpired = order.isExpiredAt(checkTime);
    assertTrue(isExpired);
}

// Clock 주입을 통한 시간 제어
@Test
void 시간_제어_테스트() {
    Clock fixedClock = Clock.fixed(
        Instant.parse("2023-01-01T10:00:00Z"), 
        ZoneOffset.UTC
    );
    
    OrderService orderService = new OrderService(fixedClock);
    Order order = orderService.createOrder(orderRequest);
    
    assertEquals(LocalDateTime.of(2023, 1, 1, 10, 0), order.getCreatedAt());
}
```

#### 4. Self-Validating (자체 검증)
```java
// ❌ 수동 검증이 필요한 테스트
@Test
void 수동_검증_테스트() {
    String result = emailService.generateWelcomeEmail("john@example.com");
    System.out.println(result);  // 개발자가 직접 확인해야 함
    // 로그를 확인하거나 파일을 열어서 검증해야 함
}

// ✅ 자체 검증하는 테스트
@Test
void 자동_검증_테스트() {
    String result = emailService.generateWelcomeEmail("john@example.com");
    
    assertThat(result)
        .contains("환영합니다")
        .contains("john@example.com")
        .contains("서비스 이용 방법");
}

@Test
void 복합_검증_테스트() {
    EmailMessage email = emailService.createWelcomeEmail("john@example.com");
    
    assertAll("Welcome Email Validation",
        () -> assertEquals("john@example.com", email.getRecipient()),
        () -> assertEquals("환영합니다!", email.getSubject()),
        () -> assertThat(email.getBody()).contains("회원가입을 축하합니다"),
        () -> assertNotNull(email.getSentDate()),
        () -> assertEquals(EmailType.WELCOME, email.getType())
    );
}
```

#### 5. Timely (적시 작성)
```java
// TDD 사이클에 따른 적시 테스트 작성

// 1단계: Red - 실패하는 테스트 먼저 작성
@Test
void 사용자_패스워드_검증_실패() {
    PasswordValidator validator = new PasswordValidator();
    // 아직 구현되지 않은 메서드
    assertFalse(validator.isValid("123"));  // 컴파일 에러
}

// 2단계: Green - 최소한의 구현
public class PasswordValidator {
    public boolean isValid(String password) {
        return password.length() >= 8;  // 최소한의 구현
    }
}

// 3단계: 더 많은 테스트 추가
@Test
void 패스워드_복잡도_검증() {
    PasswordValidator validator = new PasswordValidator();
    
    assertFalse(validator.isValid("12345678"));      // 숫자만
    assertFalse(validator.isValid("abcdefgh"));      // 문자만
    assertTrue(validator.isValid("Password1!"));     // 복합
}

// 4단계: Refactor - 구현 개선
public class PasswordValidator {
    public boolean isValid(String password) {
        if (password.length() < 8) return false;
        
        boolean hasDigit = password.matches(".*\\d.*");
        boolean hasLetter = password.matches(".*[a-zA-Z].*");
        boolean hasSpecial = password.matches(".*[!@#$%^&*].*");
        
        return hasDigit && hasLetter && hasSpecial;
    }
}
```

### AAA 패턴 (Arrange-Act-Assert)

```java
class AAAPatternExamples {
    
    @Test
    void 주문_할인_적용_테스트() {
        // Arrange (준비) - 테스트 데이터 설정
        Customer vipCustomer = Customer.builder()
            .id("customer1")
            .membershipLevel(MembershipLevel.VIP)
            .build();
        
        List<OrderItem> items = Arrays.asList(
            new OrderItem("product1", 2, 10000),
            new OrderItem("product2", 1, 5000)
        );
        
        DiscountService discountService = new DiscountService();
        
        // Act (실행) - 테스트 대상 메서드 호출
        DiscountResult result = discountService.calculateDiscount(vipCustomer, items);
        
        // Assert (검증) - 결과 검증
        assertThat(result.getDiscountAmount()).isEqualTo(2500);  // 10% 할인
        assertThat(result.getDiscountRate()).isEqualTo(0.1);
        assertThat(result.getFinalAmount()).isEqualTo(22500);
    }
    
    @Test
    void 복잡한_시나리오_AAA_패턴() {
        // Arrange
        // 1. 테스트 데이터 준비
        User user = User.builder()
            .email("test@example.com")
            .membershipLevel(MembershipLevel.GOLD)
            .points(1000)
            .build();
        
        Product product = Product.builder()
            .id("product1")
            .name("Laptop")
            .price(100000)
            .stockQuantity(10)
            .build();
        
        // 2. Mock 설정
        PaymentService mockPaymentService = mock(PaymentService.class);
        when(mockPaymentService.processPayment(any())).thenReturn(
            PaymentResult.success("PAYMENT_ID_123")
        );
        
        // 3. 서비스 인스턴스 생성
        OrderService orderService = new OrderService(
            userRepository, productRepository, mockPaymentService
        );
        
        // Act
        CreateOrderRequest request = CreateOrderRequest.builder()
            .userId(user.getId())
            .productId(product.getId())
            .quantity(2)
            .usePoints(500)
            .build();
        
        OrderResult result = orderService.createOrder(request);
        
        // Assert
        assertAll("Order Creation Result",
            () -> assertThat(result.isSuccess()).isTrue(),
            () -> assertThat(result.getOrder().getTotalAmount()).isEqualTo(195000), // 할인 적용
            () -> assertThat(result.getOrder().getUsedPoints()).isEqualTo(500),
            () -> assertThat(result.getOrder().getStatus()).isEqualTo(OrderStatus.COMPLETED)
        );
        
        // 추가 검증 - 부작용 확인
        verify(mockPaymentService).processPayment(argThat(payment -> 
            payment.getAmount().equals(BigDecimal.valueOf(195000))
        ));
    }
}
```

### 테스트 가독성 향상 패턴

#### 1. 테스트 데이터 빌더 패턴
```java
// 테스트 데이터 빌더
public class TestDataBuilder {
    
    public static UserBuilder aUser() {
        return new UserBuilder();
    }
    
    public static OrderBuilder anOrder() {
        return new OrderBuilder();
    }
    
    public static class UserBuilder {
        private String email = "default@example.com";
        private String name = "Default User";
        private MembershipLevel level = MembershipLevel.REGULAR;
        private int points = 0;
        
        public UserBuilder withEmail(String email) {
            this.email = email;
            return this;
        }
        
        public UserBuilder withName(String name) {
            this.name = name;
            return this;
        }
        
        public UserBuilder asVip() {
            this.level = MembershipLevel.VIP;
            this.points = 10000;
            return this;
        }
        
        public UserBuilder withPoints(int points) {
            this.points = points;
            return this;
        }
        
        public User build() {
            return User.builder()
                .email(email)
                .name(name)
                .membershipLevel(level)
                .points(points)
                .build();
        }
    }
}

// 사용 예시
@Test
void VIP_사용자_특별_혜택() {
    // given
    User vipUser = aUser()
        .withEmail("vip@example.com")
        .withName("VIP Customer")
        .asVip()
        .build();
    
    Order order = anOrder()
        .forUser(vipUser)
        .withItems(item("laptop", 1000000))
        .build();
    
    // when
    BenefitResult result = benefitService.calculateBenefits(order);
    
    // then
    assertThat(result)
        .hasDiscountAmount(100000)
        .hasFreeShipping()
        .hasBonusPoints(2000);
}
```

#### 2. 커스텀 매처 패턴
```java
// 커스텀 매처 정의
public class OrderMatchers {
    
    public static Matcher<Order> hasTotalAmount(int expectedAmount) {
        return new TypeSafeMatcher<Order>() {
            @Override
            protected boolean matchesSafely(Order order) {
                return order.getTotalAmount() == expectedAmount;
            }
            
            @Override
            public void describeTo(Description description) {
                description.appendText("order with total amount " + expectedAmount);
            }
        };
    }
    
    public static Matcher<Order> isCompleted() {
        return new TypeSafeMatcher<Order>() {
            @Override
            protected boolean matchesSafely(Order order) {
                return order.getStatus() == OrderStatus.COMPLETED;
            }
            
            @Override
            public void describeTo(Description description) {
                description.appendText("completed order");
            }
        };
    }
    
    public static Matcher<Order> containsProduct(String productName) {
        return new TypeSafeMatcher<Order>() {
            @Override
            protected boolean matchesSafely(Order order) {
                return order.getItems().stream()
                    .anyMatch(item -> item.getProductName().equals(productName));
            }
            
            @Override
            public void describeTo(Description description) {
                description.appendText("order containing product " + productName);
            }
        };
    }
}

// 사용 예시
@Test
void 주문_완료_검증() {
    Order order = orderService.processOrder(orderRequest);
    
    assertThat(order)
        .is(isCompleted())
        .is(hasTotalAmount(50000))
        .is(containsProduct("laptop"));
}
```

## 테스트 커버리지 전략

### 커버리지 유형별 전략

#### 1. 라인 커버리지 (Line Coverage)
```java
public class PriceCalculator {
    
    public double calculateDiscount(double price, CustomerType customerType) {
        double discount = 0;
        
        if (customerType == CustomerType.VIP) {          // Line 1
            discount = price * 0.2;                      // Line 2
        } else if (customerType == CustomerType.PREMIUM) { // Line 3
            discount = price * 0.1;                      // Line 4
        } else {                                         // Line 5
            discount = price * 0.05;                     // Line 6
        }
        
        return discount;                                 // Line 7
    }
}

// 100% 라인 커버리지를 위한 테스트
@Test
void VIP_고객_할인() {
    double discount = calculator.calculateDiscount(1000, CustomerType.VIP);
    assertEquals(200, discount);  // Line 1, 2, 7 커버
}

@Test
void 프리미엄_고객_할인() {
    double discount = calculator.calculateDiscount(1000, CustomerType.PREMIUM);
    assertEquals(100, discount);  // Line 3, 4, 7 커버
}

@Test
void 일반_고객_할인() {
    double discount = calculator.calculateDiscount(1000, CustomerType.REGULAR);
    assertEquals(50, discount);   // Line 5, 6, 7 커버
}
```

#### 2. 브랜치 커버리지 (Branch Coverage)
```java
public class OrderValidator {
    
    public ValidationResult validate(Order order) {
        List<String> errors = new ArrayList<>();
        
        // 브랜치 1: 주문 항목 검증
        if (order.getItems() == null || order.getItems().isEmpty()) {
            errors.add("주문 항목이 없습니다");
        }
        
        // 브랜치 2: 총액 검증
        if (order.getTotalAmount() <= 0) {
            errors.add("총액이 유효하지 않습니다");
        }
        
        // 브랜치 3: 고객 정보 검증
        if (order.getCustomer() == null || 
            order.getCustomer().getEmail() == null || 
            order.getCustomer().getEmail().isEmpty()) {
            errors.add("고객 이메일이 필요합니다");
        }
        
        return new ValidationResult(errors.isEmpty(), errors);
    }
}

// 모든 브랜치를 커버하는 테스트
@Test
void 유효한_주문_검증() {
    Order validOrder = createValidOrder();
    ValidationResult result = validator.validate(validOrder);
    assertTrue(result.isValid());  // 모든 if 조건이 false
}

@Test
void 빈_주문_항목_검증() {
    Order order = createOrderWithoutItems();
    ValidationResult result = validator.validate(order);
    assertFalse(result.isValid());
    assertThat(result.getErrors()).contains("주문 항목이 없습니다");
}

@Test
void 잘못된_총액_검증() {
    Order order = createOrderWithInvalidAmount();
    ValidationResult result = validator.validate(order);
    assertFalse(result.isValid());
    assertThat(result.getErrors()).contains("총액이 유효하지 않습니다");
}

@Test
void 고객_정보_누락_검증() {
    Order order = createOrderWithoutCustomer();
    ValidationResult result = validator.validate(order);
    assertFalse(result.isValid());
    assertThat(result.getErrors()).contains("고객 이메일이 필요합니다");
}
```

#### 3. 조건 커버리지 (Condition Coverage)
```java
public class AccessControl {
    
    public boolean canAccess(User user, Resource resource) {
        // 복합 조건: user가 null이 아니고 active이며, 리소스 권한이 있어야 함
        return user != null && 
               user.isActive() && 
               user.hasPermission(resource.getRequiredPermission());
    }
}

// 각 조건의 true/false를 모두 테스트
@Test
void null_사용자_접근_거부() {
    boolean canAccess = accessControl.canAccess(null, resource);
    assertFalse(canAccess);  // user != null: false
}

@Test
void 비활성_사용자_접근_거부() {
    User inactiveUser = createInactiveUser();
    boolean canAccess = accessControl.canAccess(inactiveUser, resource);
    assertFalse(canAccess);  // user.isActive(): false
}

@Test
void 권한_없는_사용자_접근_거부() {
    User userWithoutPermission = createUserWithoutPermission();
    boolean canAccess = accessControl.canAccess(userWithoutPermission, resource);
    assertFalse(canAccess);  // user.hasPermission(): false
}

@Test
void 유효한_사용자_접근_허용() {
    User validUser = createValidUser();
    boolean canAccess = accessControl.canAccess(validUser, resource);
    assertTrue(canAccess);   // 모든 조건 true
}
```

### 커버리지 목표 설정
```gradle
// build.gradle - 커버리지 설정
apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.8"
}

test {
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

// 커버리지 임계값 설정
jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.80  // 전체 80% 이상
            }
        }
        
        rule {
            element = 'CLASS'
            includes = ['com.example.core.*']  // 핵심 비즈니스 로직
            limit {
                minimum = 0.95  // 95% 이상
            }
        }
        
        rule {
            element = 'CLASS'
            includes = ['com.example.util.*']  // 유틸리티 클래스
            limit {
                minimum = 0.70  // 70% 이상
            }
        }
    }
}

check.dependsOn jacocoTestCoverageVerification
```

### 의미 있는 커버리지 추구
```java
// ❌ 커버리지만을 위한 무의미한 테스트
@Test
void 의미없는_커버리지_테스트() {
    new UserService();  // 단순히 생성자 호출
    UserService.staticMethod();  // 정적 메서드 호출
    // 실제 비즈니스 로직 검증 없음
}

// ✅ 의미 있는 비즈니스 로직 테스트
@Test
void 사용자_등급_업그레이드_로직() {
    // given
    User user = new User("john@example.com", 0);
    user.addPurchaseHistory(new Purchase(500000));  // 50만원 구매
    
    // when
    MembershipUpgradeResult result = userService.checkMembershipUpgrade(user);
    
    // then
    assertTrue(result.isEligibleForUpgrade());
    assertEquals(MembershipLevel.GOLD, result.getNewLevel());
    assertThat(result.getBenefits()).contains("무료배송", "추가할인");
}

@Test
void 예외_상황_비즈니스_로직() {
    // given
    Product outOfStockProduct = new Product("laptop", 0);  // 재고 0
    
    // when & then
    OutOfStockException exception = assertThrows(OutOfStockException.class, () -> {
        orderService.addToCart(outOfStockProduct, 1);
    });
    
    assertEquals("재고가 부족합니다", exception.getMessage());
    assertEquals("laptop", exception.getProductName());
}
```

## 테스트 환경 전략

### 환경별 테스트 분리
```java
// 프로파일별 테스트 설정
@ActiveProfiles("test")
@SpringBootTest
class LocalTestEnvironment {
    // 로컬 개발 환경 테스트
}

@ActiveProfiles("integration")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class IntegrationTestEnvironment {
    // 통합 테스트 환경
}

@ActiveProfiles("performance")
@SpringBootTest
class PerformanceTestEnvironment {
    // 성능 테스트 환경
}
```

### 테스트 컨테이너 활용
```java
@Testcontainers
@SpringBootTest
class DatabaseIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void 실제_데이터베이스_통합_테스트() {
        // given
        User user = new User("john@example.com", "John Doe");
        
        // when
        User saved = userRepository.save(user);
        
        // then
        assertNotNull(saved.getId());
        
        Optional<User> found = userRepository.findByEmail("john@example.com");
        assertTrue(found.isPresent());
        assertEquals("John Doe", found.get().getName());
    }
}
```

## 테스트 데이터 관리

### 테스트 데이터 전략
```java
// 1. 인메모리 테스트 데이터
@TestConfiguration
public class TestDataConfiguration {
    
    @Bean
    @Primary
    public UserRepository testUserRepository() {
        return new InMemoryUserRepository();
    }
    
    @EventListener
    public void handleTestExecutionStarted(TestExecutionStartedEvent event) {
        // 테스트 시작 시 기본 데이터 로드
        loadTestData();
    }
    
    private void loadTestData() {
        // 기본 테스트 사용자들
        testUserRepository().save(new User("admin@test.com", "Admin", Role.ADMIN));
        testUserRepository().save(new User("user@test.com", "User", Role.USER));
    }
}

// 2. 테스트 픽스처 팩토리
public class UserFixtures {
    
    public static User adminUser() {
        return User.builder()
            .email("admin@test.com")
            .name("Test Admin")
            .role(Role.ADMIN)
            .status(UserStatus.ACTIVE)
            .build();
    }
    
    public static User regularUser() {
        return User.builder()
            .email("user@test.com")
            .name("Test User")
            .role(Role.USER)
            .status(UserStatus.ACTIVE)
            .build();
    }
    
    public static User inactiveUser() {
        return User.builder()
            .email("inactive@test.com")
            .name("Inactive User")
            .role(Role.USER)
            .status(UserStatus.INACTIVE)
            .build();
    }
}

// 3. 데이터베이스 클리너
@Component
public class DatabaseCleaner {
    
    @Autowired
    private EntityManager entityManager;
    
    @Transactional
    public void cleanUp() {
        entityManager.flush();
        entityManager.createNativeQuery("SET REFERENTIAL_INTEGRITY FALSE").executeUpdate();
        
        // 모든 테이블 데이터 삭제
        List<String> tableNames = getTableNames();
        for (String tableName : tableNames) {
            entityManager.createNativeQuery("TRUNCATE TABLE " + tableName).executeUpdate();
        }
        
        entityManager.createNativeQuery("SET REFERENTIAL_INTEGRITY TRUE").executeUpdate();
    }
    
    private List<String> getTableNames() {
        return entityManager.createNativeQuery(
            "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC'"
        ).getResultList();
    }
}

// 사용 예시
@SpringBootTest
@Transactional
class OrderServiceTest {
    
    @Autowired
    private DatabaseCleaner databaseCleaner;
    
    @BeforeEach
    void setUp() {
        databaseCleaner.cleanUp();
    }
    
    @Test
    void 주문_생성_테스트() {
        // given
        User user = UserFixtures.regularUser();
        userRepository.save(user);
        
        // when & then
        // 테스트 로직
    }
}
```

## CI/CD와 테스트 자동화

### GitHub Actions 설정
```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
    
    - name: Run Unit Tests
      run: ./gradlew test --parallel
    
    - name: Run Integration Tests
      run: ./gradlew integrationTest --parallel
      env:
        SPRING_PROFILES_ACTIVE: integration
    
    - name: Generate Test Report
      run: ./gradlew jacocoTestReport
    
    - name: Upload Coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./build/reports/jacoco/test/jacocoTestReport.xml
    
    - name: Comment PR with Test Results
      if: github.event_name == 'pull_request'
      uses: dorny/test-reporter@v1
      with:
        name: Test Results
        path: '**/build/test-results/test/TEST-*.xml'
        reporter: java-junit
```

### 테스트 자동화 전략
```java
// 1. 테스트 태깅으로 선택적 실행
@Tag("unit")
@Test
void 단위_테스트() {
    // 빠른 단위 테스트
}

@Tag("integration")
@Test
void 통합_테스트() {
    // 중간 속도 통합 테스트
}

@Tag("slow")
@Test
void 느린_테스트() {
    // 시간이 오래 걸리는 테스트
}

// build.gradle에서 태그별 실행
test {
    useJUnitPlatform {
        excludeTags 'slow'  // 기본적으로 느린 테스트 제외
    }
}

task slowTest(type: Test) {
    useJUnitPlatform {
        includeTags 'slow'  // 느린 테스트만 실행
    }
}

// 2. 병렬 테스트 실행 설정
test {
    maxParallelForks = Runtime.runtime.availableProcessors()
    systemProperty 'junit.jupiter.execution.parallel.enabled', 'true'
    systemProperty 'junit.jupiter.execution.parallel.mode.default', 'concurrent'
}

// 3. 테스트 실패 시 즉시 중단
test {
    failFast = true  // 첫 번째 실패 시 중단
}
```

## 성능 테스트 전략

### JMH를 이용한 마이크로 벤치마크
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class PerformanceBenchmark {
    
    private List<User> users;
    private UserService userService;
    
    @Setup
    public void setUp() {
        users = IntStream.range(0, 10000)
            .mapToObj(i -> new User("user" + i + "@example.com", "User " + i))
            .collect(Collectors.toList());
        
        userService = new UserService();
    }
    
    @Benchmark
    public List<User> filterActiveUsers() {
        return users.stream()
            .filter(User::isActive)
            .collect(Collectors.toList());
    }
    
    @Benchmark
    public List<User> filterActiveUsersParallel() {
        return users.parallelStream()
            .filter(User::isActive)
            .collect(Collectors.toList());
    }
    
    @Benchmark
    public void batchProcessUsers() {
        userService.batchProcess(users);
    }
}
```

### 부하 테스트
```java
@Test
void 동시_요청_부하_테스트() throws InterruptedException {
    int threadCount = 100;
    int requestsPerThread = 10;
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger errorCount = new AtomicInteger(0);
    
    long startTime = System.currentTimeMillis();
    
    for (int i = 0; i < threadCount; i++) {
        executor.submit(() -> {
            try {
                for (int j = 0; j < requestsPerThread; j++) {
                    try {
                        User user = userService.createUser(generateRandomUser());
                        successCount.incrementAndGet();
                    } catch (Exception e) {
                        errorCount.incrementAndGet();
                    }
                }
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(30, TimeUnit.SECONDS);
    long endTime = System.currentTimeMillis();
    
    int totalRequests = threadCount * requestsPerThread;
    long duration = endTime - startTime;
    double throughput = (double) successCount.get() / duration * 1000;  // requests per second
    
    System.out.println("Total requests: " + totalRequests);
    System.out.println("Successful requests: " + successCount.get());
    System.out.println("Failed requests: " + errorCount.get());
    System.out.println("Duration: " + duration + "ms");
    System.out.println("Throughput: " + throughput + " requests/sec");
    
    // 성능 기준 검증
    assertThat(successCount.get()).isGreaterThan(totalRequests * 0.95);  // 95% 이상 성공
    assertThat(throughput).isGreaterThan(100);  // 최소 100 requests/sec
}
```

## 테스트 유지보수 전략

### 테스트 리팩토링
```java
// ❌ 중복이 많은 테스트
class DuplicatedTestExample {
    
    @Test
    void VIP_고객_할인_테스트() {
        User user = new User();
        user.setEmail("vip@example.com");
        user.setMembershipLevel(MembershipLevel.VIP);
        user.setPoints(10000);
        
        Order order = new Order();
        order.setCustomer(user);
        order.addItem(new OrderItem("product1", 100000, 1));
        
        DiscountResult result = discountService.calculateDiscount(order);
        
        assertEquals(10000, result.getDiscountAmount());
    }
    
    @Test
    void 골드_고객_할인_테스트() {
        User user = new User();
        user.setEmail("gold@example.com");
        user.setMembershipLevel(MembershipLevel.GOLD);
        user.setPoints(5000);
        
        Order order = new Order();
        order.setCustomer(user);
        order.addItem(new OrderItem("product1", 100000, 1));
        
        DiscountResult result = discountService.calculateDiscount(order);
        
        assertEquals(5000, result.getDiscountAmount());
    }
}

// ✅ 리팩토링된 테스트
class RefactoredTestExample {
    
    @ParameterizedTest
    @CsvSource({
        "VIP, 10000, 10000",
        "GOLD, 5000, 5000", 
        "SILVER, 0, 3000",
        "REGULAR, 0, 0"
    })
    void 회원_등급별_할인_테스트(MembershipLevel level, int points, int expectedDiscount) {
        // given
        User user = createUser(level, points);
        Order order = createOrder(user, 100000);
        
        // when
        DiscountResult result = discountService.calculateDiscount(order);
        
        // then
        assertEquals(expectedDiscount, result.getDiscountAmount());
    }
    
    private User createUser(MembershipLevel level, int points) {
        return User.builder()
            .email("test@example.com")
            .membershipLevel(level)
            .points(points)
            .build();
    }
    
    private Order createOrder(User user, int amount) {
        return Order.builder()
            .customer(user)
            .items(Arrays.asList(new OrderItem("product1", amount, 1)))
            .build();
    }
}
```

### 테스트 문서화
```java
/**
 * 주문 서비스의 핵심 비즈니스 로직을 검증하는 테스트
 * 
 * 테스트 범위:
 * - 주문 생성 로직
 * - 할인 적용 로직  
 * - 재고 관리 로직
 * - 결제 연동 로직
 * 
 * 테스트 환경:
 * - H2 인메모리 데이터베이스 사용
 * - 외부 결제 API는 Mock으로 대체
 * - 테스트 데이터는 @BeforeEach에서 초기화
 */
@DisplayName("주문 서비스 테스트")
class OrderServiceTest {
    
    @Nested
    @DisplayName("주문 생성")
    class OrderCreation {
        
        @Test
        @DisplayName("정상적인 주문 생성 시 주문 상태가 PENDING이어야 한다")
        void 정상_주문_생성() {
            // 테스트 구현
        }
        
        @Test
        @DisplayName("재고가 부족한 상품 주문 시 예외가 발생해야 한다")
        void 재고_부족_예외() {
            // 테스트 구현
        }
    }
    
    @Nested
    @DisplayName("할인 적용")
    class DiscountApplication {
        
        @Test
        @DisplayName("VIP 고객은 10% 할인이 적용되어야 한다")
        void VIP_할인_적용() {
            // 테스트 구현
        }
    }
}
```

## 마무리

효과적인 테스트 전략은 소프트웨어 품질의 핵심입니다.

**핵심 포인트:**
- **테스트 피라미드**: 단위 테스트 중심의 균형 잡힌 테스트 구성
- **FIRST 원칙**: 빠르고, 독립적이며, 반복 가능한 테스트
- **적절한 커버리지**: 100%가 아닌 의미 있는 커버리지 추구
- **자동화**: CI/CD와 연계된 지속적인 테스트 실행
- **유지보수**: 테스트 코드도 프로덕션 코드와 동일한 수준의 관리

좋은 테스트 전략은 개발 속도를 높이고 버그를 줄여 안정적인 소프트웨어 개발을 가능하게 합니다.